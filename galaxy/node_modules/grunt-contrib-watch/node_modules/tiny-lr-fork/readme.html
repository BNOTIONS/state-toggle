<!DOCTYPE html><html><head><link rel="stylesheet" href="galaxy/galaxy.css"><link rel="stylesheet" href="styles/docs.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.css"></head><body><p>This is a fork of tiny-lr. The maintainer of tiny-lr appears to be on a hiatus and this fork takes care of lingering issues until the maintainer of tiny-lr (hopefully) returns.</p>
<p><strong>Changes made:</strong></p>
<ul>
<li>Quieter, removes <code>console.log</code>s</li>
<li>Use WSS when livereload.js is on HTTPS</li>
<li>Normalize windows paths in livereload.js</li>
</ul>
<hr>
<h2>tiny-lr</h2>
<p>This script manages a tiny <a href="http://livereload.com/">LiveReload</a> server
implementation you can spawn in the background.</p>
<p>It exposes:</p>
<ul>
<li><p>a background-friendly bin wrapper (thanks to
<a href="https://github.com/FGRibreau">@FGRibreau</a> <a href="https://gist.github.com/1846952">pid.js
gist</a>)</p>
</li>
<li><p><a href="https://github.com/mklabs/tiny-lr#using-grunt">Grunt tasks</a> to start the server and trigger reload notification. Every task
name is prefixed by <code>tinylr-</code>.</p>
</li>
<li><p><a href="https://github.com/mklabs/tiny-lr#using-make">Generic targets</a> to include in
your Makefile (<code>include node_modules/tiny-lr/tasks/tiny-lr.mk</code>)</p>
</li>
</ul>
<p>It doesn&#39;t have any watch ability, it must be done at the build process or
application level.</p>
<p>Instead, it exposes a very simple API to notify the server that some
changes have been made, that is then broadcasted to every livereload client
connected.</p>
<pre><code># notify a single change
curl http://localhost:35729/changed?files=style.css

# notify using a longer path
curl http://localhost:35729/changed?files=js/app.js

# notify multiple changes, comma or space delimited
curl http://localhost:35729/changed?files=index.html,style.css,docs/docco.css</code></pre>
<p>Or you can bulk the information into a POST request, with body as a JSON array of files.</p>
<pre><code>curl -X POST http://localhost:35729/changed -d &#39;{ &quot;files&quot;: [&quot;style.css&quot;, &quot;app.js&quot;] }&#39;</code></pre>
<p>As for the livereload client, you need to install the browser extension:
<a href="http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-">http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-</a>
(<strong>note</strong>: you need to listen on port 35729 to be able to use with your
brower extension)</p>
<p>or add the livereload script tag manually:
<a href="http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-">http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-</a>
(and here you can choose whatever port you want)</p>
<h2>Integration</h2>
<p>This package exposes a <code>bin</code> you can decide to install globally, but it&#39;s not recommended.</p>
<pre><code>tiny-lr --help

Usage: tiny-lr [options]

Options:
  -h, --help        - Show help usage
  -v, --version     - Show package version
  -p, --port        - Port to listen on (default: 35729)
  --pid             - Path to the generated PID file (default: ./tiny-lr.pid)</code></pre>
<p>The best way to integrate the runner in your workflow is to add it as a <code>reload</code>
step within your build tool. This build tool can then use the internal binary
linked by npm in <code>node_modules/.bin/tiny-lr</code> to not rely on global installs (or
use the server programmtically).</p>
<p>You can start the server using the binary provided, or use your own start script.</p>
<pre><code class="language-js">var tinylr = require(&#39;tiny-lr&#39;);

// standard LiveReload port
var port = 35729;

// tinylr(opts) =&gt; new tinylr.Server(opts);
tinylr().listen(port, function() {
  if(err) {
    // deal with err
    return;
  }

  console.log(&#39;... Listening on %s (pid: %s) ...&#39;, port);
})</code></pre>
<p>You can define your own route and listen for specific request:</p>
<pre><code class="language-js">var server = tinylr();

server.on(&#39;GET /myplace&#39;, function(req, res) {
  res.write(&#39;Mine&#39;);
  res.end();
})</code></pre>
<p>And stop the server manually:</p>
<pre><code class="language-js">server.close();</code></pre>
<p>This will close any websocket connection established and emit a close event.</p>
<h3>Middleware</h3>
<p>To use as a connect / express middleware, tiny-lr needs query /
bodyParse middlewares prior in the stack.</p>
<p>Any handled requests ends at the tinylr level, not found and errors are
nexted to the rest of the stack.</p>
<pre><code class="language-js">// This binds both express app and tinylr on the same port
var app = express();
app.use(express.query())
  .use(express.bodyParser())
  .use(tinylr.middleware({ app: app }))
  .use(express.static(path.resolve(&#39;./&#39;)))
  .use(express.directory(path.resolve(&#39;./&#39;)))
  .listen(35729, function() {
    console.log(&#39;Listening on %d&#39;, 35729);
  })</code></pre>
<p>The port you listen on is important, and tinylr should <strong>always</strong> listen on
the LiveReload standard one: <code>35729</code>. Otherwise, you won&#39;t be able to rely
on the browser extensions, though you can still use the manual snippet
approach.</p>
<p>You can also start two different servers, one on your app port, the
other listening on the LiveReload port. Check the
<code>examples/express/server.js</code> file to see how.</p>
<h3>Using grunt</h3>
<p>This package exposes a <code>tasks/</code> directory, that you can use within your Gruntfile with:</p>
<pre><code class="language-js">grunt.loadNpmTasks(&#39;tiny-lr&#39;);</code></pre>
<ul>
<li>tinylr-start    - Starts a new tiny-lr Server, with the provided port.</li>
<li>tinylr-reload   - Sends a reload notification to the previously started server.</li>
</ul>
<p><code>tinylr-start</code> should be used with the <code>watch</code> task, probably with an alias
that triggers both <code>tinylr-start watch</code> tasks.</p>
<p><code>tinylr-reload</code> should be configured as a &quot;watch&quot; task in your Gruntfile.</p>
<pre><code class="language-js">grunt.initConfig({
  watch: {
    reload: {
      files: [&#39;**/*.html&#39;, &#39;**/*.js&#39;, &#39;**/*.css&#39;, &#39;**/*.{png,jpg}&#39;],
      tasks: &#39;tinylr-reload&#39;
    }
  }
});

grunt.registerTask(&#39;reload&#39;, [&#39;tinylr-start&#39;, &#39;watch&#39;]);</code></pre>
<h3>Using make</h3>
<p>See <code>tasks/tiny-lr.mk</code>.</p>
<p>Include this file into your project Makefile to bring in the following targets:</p>
<ul>
<li>start                         - Start the LiveReload server</li>
<li>stop                             - Stops the LiveReload server</li>
<li>livereload                 - alias to start</li>
<li>livereload-stop     - aias to stop</li>
</ul>
<p>Then define your &quot;empty&quot; targets, and the list of files you want to monitor.</p>
<pre><code class="language-make">CSS_DIR = app/styles
CSS_FILES = $(shell find $(CSS_DIR) -name &#39;*.css&#39;)

# include the livereload targets
include node_modules/tiny-lr/tasks/*.mk

$(CSS_DIR): $(CSS_FILES)
  @echo CSS files changed: $?
    @touch $@
  curl -X POST http://localhost:35729/changed -d &#39;{ &quot;files&quot;: &quot;$?&quot; }&#39;

reload-css: livereload $(CSS_DIR)

.PHONY: reload-css</code></pre>
<p>The pattern is always the same:</p>
<ul>
<li>define a target for your root directory that triggers a POST request</li>
<li><code>touch</code> the directory to update its mtime</li>
<li>add reload target with <code>livereload</code> and the list of files to &quot;watch&quot; as
prerequisites</li>
</ul>
<p>You can chain multiple &quot;reload&quot; targets in a single one:</p>
<pre><code class="language-make">reload: reload-js reload-css reload-img reload-EVERYTHING</code></pre>
<p>Combine this with <a href="https://github.com/visionmedia/watch">visionmedia/watch</a> and
you have a livereload environment.</p>
<pre><code>watch make reload

# add a -q flag to the watch command to suppress most of the annoying output
watch -q reload</code></pre>
<p>The <code>-q</code> flag only outputs STDERR, you can in your Makefile redirect the
output of your commands to <code>&gt;&amp;2</code> to see them in <code>watch -q</code> mode.</p>
<h2>Tests</h2>
<pre><code>npm test</code></pre>
<hr>
<h1>TOC</h1>
<ul>
<li><a href="#tiny-lr">tiny-lr</a><ul>
<li><a href="#tiny-lr-get-">GET /</a></li>
<li><a href="#tiny-lr-get-changed">GET /changed</a></li>
<li><a href="#tiny-lr-post-changed">POST /changed</a></li>
<li><a href="#tiny-lr-get-livereloadjs">GET /livereload.js</a></li>
<li><a href="#tiny-lr-get-kill">GET /kill</a>
<a name="" /></li>
</ul>
</li>
</ul>
<p><a name="tiny-lr" /></p>
<h1>tiny-lr</h1>
<p>accepts ws clients.</p>
<pre><code class="language-js">var url = parse(this.request.url);
var server = this.app;

var ws = this.ws = new WebSocket(&#39;ws://&#39; + url.host + &#39;/livereload&#39;);

ws.onopen = function(event) {
  var hello = {
    command: &#39;hello&#39;,
    protocols: [&#39;http://livereload.com/protocols/official-7&#39;]
  };

  ws.send(JSON.stringify(hello));
};

ws.onmessage = function(event) {
  assert.deepEqual(event.data, JSON.stringify({
    command: &#39;hello&#39;,
    protocols: [&#39;http://livereload.com/protocols/official-7&#39;],
    serverName: &#39;tiny-lr&#39;
  }));

  assert.ok(Object.keys(server.clients).length);
  done();
};</code></pre>
<p>properly cleans up established connection on exit.</p>
<pre><code class="language-js">var ws = this.ws;

ws.onclose = done.bind(null, null);

request(this.server)
  .get(&#39;/kill&#39;)
  .expect(200, function() {
    console.log(&#39;server shutdown&#39;);
  });</code></pre>
<p><a name="tiny-lr" /></p>
<h1>tiny-lr</h1>
<p><a name="tiny-lr-get-" /></p>
<h2>GET /</h2>
<p>respond with nothing, but respond.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(&#39;{&quot;tinylr&quot;:&quot;Welcome&quot;,&quot;version&quot;:&quot;0.0.1&quot;}&#39;)
  .expect(200, done);</code></pre>
<p>unknown route respond with proper 404 and error message.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/whatev&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(&#39;{&quot;error&quot;:&quot;not_found&quot;,&quot;reason&quot;:&quot;no such route&quot;}&#39;)
  .expect(404, done);</code></pre>
<p><a name="tiny-lr-get-changed" /></p>
<h2>GET /changed</h2>
<p>with no clients, no files.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/changed&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(/&quot;clients&quot;:\[\]/)
  .expect(/&quot;files&quot;:\[\]/)
  .expect(200, done);</code></pre>
<p>with no clients, some files.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/changed?files=gonna.css,test.css,it.css&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(&#39;{&quot;clients&quot;:[],&quot;files&quot;:[&quot;gonna.css&quot;,&quot;test.css&quot;,&quot;it.css&quot;]}&#39;)
  .expect(200, done);</code></pre>
<p><a name="tiny-lr-post-changed" /></p>
<h2>POST /changed</h2>
<p>with no clients, no files.</p>
<pre><code class="language-js">request(this.server)
  .post(&#39;/changed&#39;)
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(/&quot;clients&quot;:\[\]/)
  .expect(/&quot;files&quot;:\[\]/)
  .expect(200, done);</code></pre>
<p>with no clients, some files.</p>
<pre><code class="language-js">var data = { clients: [], files: [&#39;cat.css&#39;, &#39;sed.css&#39;, &#39;ack.js&#39;] };

request(this.server)
  .post(&#39;/changed&#39;)
  .send({ files: data.files })
  .expect(&#39;Content-Type&#39;, /json/)
  .expect(JSON.stringify(data))
  .expect(200, done);</code></pre>
<p><a name="tiny-lr-get-livereloadjs" /></p>
<h2>GET /livereload.js</h2>
<p>respond with livereload script.</p>
<pre><code class="language-js">request(this.server)
  .get(&#39;/livereload.js&#39;)
  .expect(/LiveReload/)
  .expect(200, done);</code></pre>
<p><a name="tiny-lr-get-kill" /></p>
<h2>GET /kill</h2>
<p>shutdown the server.</p>
<pre><code class="language-js">var server = this.server;
request(server)
  .get(&#39;/kill&#39;)
  .expect(200, function(err) {
    if(err) return done(err);
    assert.ok(!server._handle);
    done();
  });</code></pre>
<hr>
<ul>
<li>2013-01-21 - v0.0.5 - <a href="https://github.com/mklabs/tiny-lr/pull/18">PR #18</a> / <a href="https://github.com/mklabs/tiny-lr/pull/21">PR #21</a> - https support / expose reload flags through options</li>
<li>2013-01-21 - v0.0.4 - middleware support</li>
<li>2013-01-20 - v0.0.3 - serve livereload from repo (#4)</li>
<li>2013-01-12 - v0.0.2 - tasks - support for grunt 0.3.x (#1)</li>
<li>2013-01-05 - v0.0.1 - Initial release</li>
</ul>
<script src="//code.jquery.com/jquery.min.css"></script><script src="https://galaxyui.com/js/prism.js"></script><script async src="//assets.codepen.io/assets/embed/ei.js"></script></body></html>