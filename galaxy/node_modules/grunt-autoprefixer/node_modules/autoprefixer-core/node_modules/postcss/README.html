<!DOCTYPE html><html><head><link rel="stylesheet" href="galaxy/galaxy.css"><link rel="stylesheet" href="//cloud.typography.com/6579472/723444/css/fonts.css"><script src="jquery.js"></script><script src="docs.js"></script><script src="https://galaxyui.com/js/prism.js"></script></head><body ondragstart="return false"><header><ul><li><a href="//www.bnotions.com"><img src="media/logo.svg" width="130"></a></li><li><a href="http://www.bnotions.com/insights/">Stories</a></li><li><a href="https://medium.com/bnotions">Screen Theory</a></li></ul></header><h1>PostCSS <a href="https://travis-ci.org/postcss/postcss"><img src="https://travis-ci.org/postcss/postcss.svg" alt="Build Status"></a> <a href="https://gitter.im/postcss/postcss?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge">![Gitter](<a href="https://badges.gitter.im/Join">https://badges.gitter.im/Join</a> Chat.svg)</a></h1>
<p><img align="right" width="95" height="95" src="http://postcss.github.io/postcss/logo.svg" title="Philosopher’s stone, logo of PostCSS"></p>
<p>PostCSS is a framework for CSS postprocessors,
to modify CSS with JavaScript with full source map support.</p>
<p>It takes care of the most common CSS tool tasks:</p>
<ol>
<li>parses CSS;</li>
<li>provides a usable JS API to edit CSS node trees;</li>
<li>dumps the modified node tree into a CSS string;</li>
<li>generates a source map (or modifies an pre-existing source map) containing
your changes;</li>
</ol>
<p>You can use this framework to write your own:</p>
<ul>
<li>CSS minifier or beautifier.</li>
<li>CSS polyfills.</li>
<li>Grunt plugin to generate sprites, include <code>data-uri</code> images
or any other work.</li>
<li>Text editor plugin to automate CSS routines.</li>
<li>Command-line CSS tool.</li>
</ul>
<p>Twitter account for news, releases and new plugins: <a href="https://twitter.com/postcss">@postcss</a>.
Weibo account: <a href="http://weibo.com/postcss">postcss</a>.</p>
<p><a href="https://evilmartians.com/?utm_source=postcss">
<img src="https://evilmartians.com/badges/sponsored-by-evil-martians.svg" alt="Sponsored by Evil Martians" width="236" height="54">
</a></p>
<h2>Built with PostCSS</h2>
<h3>Tools</h3>
<ul>
<li><a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> adds vendor prefixes by Can I Use data.</li>
<li><a href="https://github.com/necolas/postcss-bem-linter">BEM linter</a> lints CSS for SUIT CSS methodology.</li>
<li><a href="https://github.com/hail2u/node-css-mqpacker">CSS MQPacker</a> joins same media queries.</li>
<li><a href="https://github.com/vovanbo/css2modernizr">css2modernizr</a> analyzes your CSS and output only used Modernizr’s settings.</li>
<li><a href="https://github.com/putaindecode/cssnext">cssnext</a> is a transpiler (CSS 4+ to CSS 3) that allow you to use tomorrow’s
CSS syntax today.</li>
<li><a href="https://github.com/hail2u/node-csswring">CSSWring</a> is a CSS minifier with full source map support.</li>
<li><a href="https://github.com/Sebastian-Fitzner/grunt-data-separator">data-separator</a> splits data-uri into a separate CSS file.</li>
<li><a href="https://github.com/robwierzbowski/node-pixrem">pixrem</a> is a <code>rem</code> unit polyfill.</li>
<li><a href="https://github.com/lexich/webpcss">webpcss</a> to duplicate images in CSS to WebP for supported browsers.</li>
<li><a href="http://pleeease.io/">Pleeease</a> is a pack of various postprocessors.</li>
<li><a href="https://github.com/iamvdo/pleeease-filters">Pleeease Filters</a> converts WebKit filters to SVG filter for other browsers.</li>
<li><a href="https://github.com/MohammadYounes/rtlcss">RTLCSS</a> mirrors styles for right-to-left locales.</li>
<li><a href="https://github.com/AoDev/css-byebye">CSS Byebye</a> explicitly removes the CSS rules that you don’t want.</li>
<li><a href="https://github.com/Rycochet/postcss-epub">postcss-epub</a> to prefix ePub3 properties.</li>
<li><a href="https://github.com/anandthakker/doiuse">doiuse</a> to lint your CSS on unsupported properties by Can I Use.</li>
<li><a href="https://github.com/borodean/postcss-assets">postcss-assets</a> to inline files and insert image width and height.</li>
<li><a href="https://github.com/morishitter/acss">ACSS</a> Annotations based CSS processor.</li>
<li><a href="https://github.com/cssdream/cssgrace">CSS Grace</a> to CSS 3 polyfills for IE and other old browsers.</li>
<li><a href="https://github.com/cvrebert/mq4-hover-hover-shim">mq4-hover-hover-shim</a> is a shim for the <code>hover</code> media feature from Media
Queries Level 4.</li>
</ul>
<h3>Plugins</h3>
<ul>
<li><a href="https://github.com/postcss/postcss-calc">postcss-calc</a> to reduce <code>calc()</code> usage
(recommended with <code>postcss-custom-properties</code>).</li>
<li><a href="https://github.com/postcss/postcss-color-function">postcss-color-function</a> to transform <code>color()</code> function.</li>
<li><a href="https://github.com/postcss/postcss-color-gray">postcss-color-gray</a> to transform <code>gray()</code> function.</li>
<li><a href="https://github.com/postcss/postcss-color-hex-alpha">postcss-color-hex-alpha</a> to transform hexadecimal notations with alpha
(<code>#rrggbbaa</code> or <code>#rgba</code>).</li>
<li><a href="https://github.com/postcss/postcss-color-hwb">postcss-color-hwb</a> to transform <code>hwb()</code> function.</li>
<li><a href="https://github.com/postcss/postcss-color-rebeccapurple">postcss-color-rebeccapurple</a> to transform <code>rebeccapurple</code> color.</li>
<li><a href="https://github.com/postcss/postcss-import">postcss-import</a> to transform <code>@import</code> rules by inlining content.</li>
<li><a href="https://github.com/postcss/postcss-custom-media">postcss-custom-media</a> to add names for Media Queries.</li>
<li><a href="https://github.com/postcss/postcss-custom-properties">postcss-custom-properties</a> to transform Custom Properties
for cascading variables.</li>
<li><a href="https://github.com/postcss/postcss-url">postcss-url</a> to rebase or inline on <code>url()</code>.</li>
<li><a href="https://github.com/postcss/postcss-font-variant">postcss-font-variant</a> to set <code>font-feature-settings</code> by readable properties.</li>
<li><a href="https://github.com/postcss/postcss-nested">postcss-nested</a> to unwrap rules in other rules, like you can write in Sass.</li>
<li><a href="https://github.com/postcss/postcss-custom-selector">postcss-custom-selector</a> to add custom alias for selectors.</li>
<li><a href="https://github.com/postcss/postcss-media-minmax">postcss-media-minmax</a> to use <code>&lt;=</code> or <code>&gt;=</code> in CSS Media Queries.</li>
<li><a href="https://github.com/Ser-Gen/postcss-data-packer">postcss-data-packer</a> to move an embedded data into a separate file.</li>
<li><a href="https://github.com/zaim/postcss-color-palette">postcss-color-palette</a> to transform CSS2 color keywords to a custom palette.</li>
<li><a href="https://github.com/TrySound/postcss-color-hex">postcss-color-hex</a> to transform rgb() and rgba() to hex.</li>
<li><a href="https://github.com/hail2u/postcss-single-charset">postcss-single-charset</a> to pop first <code>@charset</code> rule.</li>
<li><a href="https://github.com/davidtheclark/postcss-simple-extend">postcss-simple-extend</a> to add selectors to a previously defined rule set.</li>
<li><a href="https://github.com/davidtheclark/postcss-simple-mixin">postcss-simple-mixin</a> to clone declarations from abstract definitions into any rule sets that follow.</li>
</ul>
<h2>Quick Example</h2>
<p>Let’s fix a forgotten <code>content</code> property in <code>::before</code> and <code>::after</code>:</p>
<pre><code class="language-js">var postcss = require(&#39;postcss&#39;);

var contenter = postcss(function (css) {
    css.eachRule(function (rule) {
        if ( rule.selector.match(/::(before|after)/) ) {
            // In each ::before/::after rule

            // Did we forget the content property?
            var good = rule.some(function (i) { return i.prop == &#39;content&#39;; });

            if ( !good ) {
                // Add content: &quot;&quot; if we forget it
                rule.prepend({ prop: &#39;content&#39;, value: &#39;&quot;&quot;&#39; });
            }

        }
    });
});</code></pre>
<p>And the CSS with a forgotten <code>content</code> property:</p>
<pre><code class="language-css">a::before {
    width: 10px;
    height: 10px
}</code></pre>
<p>will be fixed by our new <code>contenter</code>:</p>
<pre><code class="language-js">var fixed = contenter.process(css).css;</code></pre>
<p>to:</p>
<pre><code class="language-css">a::before {
    content: &quot;&quot;;
    width: 10px;
    height: 10px
}</code></pre>
<h2>Features</h2>
<h3>Source Map</h3>
<p>PostCSS generates a source map of its changes:</p>
<pre><code class="language-js">result = processor.process(css, { map: true, from: &#39;from.css&#39;, to: &#39;to.css&#39; });
result.css // String with processed CSS and inlined source map</code></pre>
<p>And modifies a source map from previous steps (for example, Sass preprocessor):</p>
<pre><code class="language-js">var sass = compiler.compile(sass);

processor.process(sass.css, {
    map:  { prev: sass.map },
    from: &#39;from.sass.css&#39;,
    to:   &#39;to.css&#39;
});</code></pre>
<h3>Preserves code formatting and indentations</h3>
<p>PostCSS will not change any byte of a rule, if you do not modify its node:</p>
<pre><code class="language-js">postcss(function (css) { }).process(css).css == css;</code></pre>
<p>And when you modify CSS nodes, PostCSS will try to copy the coding style:</p>
<pre><code class="language-js">contenter.process(&quot;a::before{color:black}&quot;)
// a::before{content:&#39;&#39;;color:black}

contenter.process(&quot;a::before {\n  color: black;\n  }&quot;)
// a::before {
//   content: &#39;&#39;;
//   color: black;
//   }</code></pre>
<p>Which allows you to use PostCSS in text editor plugins while preserving
the user’s code style.</p>
<h2>Why PostCSS Better Than …</h2>
<h3>Preprocessors</h3>
<p>Preprocessors (like Sass or Stylus) give us special languages with variables,
mixins, and statements, which are compiled to CSS. Compass, nib and other mixins
libraries use these languages to work with prefixes, sprites and inline images.</p>
<p>But the Sass and Stylus languages were created to be syntax-sugar for CSS.
Writing complicated programs using preprocessor languages can be very difficult.
For example, it would be impossible to implement <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> on top of Sass.</p>
<p>PostCSS gives you the comfort and power of JS or CoffeeScript while
you are working with CSS. Applying the depth and variety of <a href="https://npmjs.org/">npm</a>’s libraries
allows you to perform quite magical things using PostCSS.</p>
<p>An important point is that postprocessors are not the enemies of preprocessors.
Preprocessors and postprocessors can be easily combined, so that you can take
advantage of the readability and syntactical sugar offered by Sass and Stylus;
and PostCSS will preserve their source maps.</p>
<h3>Regular Expressions</h3>
<p>Some Grunt plugins modify CSS with regular expressions, however a parser
and its node tree provide a much safer interface to edit CSS. Furthermore,
regular expressions typically break the source maps generated by preprocessors.</p>
<h3>CSS Parsers</h3>
<p>There are a lot of good CSS parsers, such as <a href="https://github.com/css/gonzales">Gonzales</a>, but they only help you
to read in the CSS. PostCSS provides you with full source map support and a
high level API. Safe iterators, and other features, are unique to PostCSS.</p>
<h3>Rework</h3>
<p><a href="https://github.com/visionmedia/rework">Rework</a> and PostCSS are very similar, but they have different targets.</p>
<p>Rework was created to build a new CSS sublanguage that replaced Stylus
(like <a href="http://www.myth.io/">Myth</a>). PostCSS was created for CSS tools which work with legacy CSS code
(one such tool is Autoprefixer).</p>
<p>Because of this fundamental difference, PostCSS:</p>
<ul>
<li>Handles source map better, because it updates the map from the previous step
(for example, Sass compilation).</li>
<li>Preserves all your spaces and code style, so that it can function
in text editor plugins.</li>
<li>Has a safer parser, so that it can be used for legacy code. Only PostCSS can
parse all of the hacks from <a href="http://browserhacks.com/">Browserhacks.com</a>.</li>
<li>Has a high level API to provide an simple interface for your processor to
perform typical tasks.</li>
</ul>
<h2>Usage</h2>
<h3>Grunt</h3>
<p>Grunt plugin <a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a> allows you to pipe your CSS files through
an array of PostCSS processors.</p>
<pre><code class="language-js">grunt.initConfig({
    postcss: {
        options: {
            map: true,
            processors: [
                require(&#39;autoprefixer-core&#39;).postcss,
                require(&#39;csswring&#39;).postcss
            ]
        },
        dist: {
            src: &#39;css/*.css&#39;
        }
    }
});

grunt.loadNpmTasks(&#39;grunt-postcss&#39;);</code></pre>
<h3>Gulp</h3>
<p>There is a Gulp plugin for PostCSS called <a href="https://github.com/w0rm/gulp-postcss">gulp-postcss</a> that allows you
to pipe your CSS files through an array of PostCSS processors.</p>
<p>Support for external source maps is provided by <a href="https://github.com/floridoo/gulp-sourcemaps">gulp-sourcemaps</a>.</p>
<pre><code class="language-js">var postcss    = require(&#39;gulp-postcss&#39;);
var sourcemaps = require(&#39;gulp-sourcemaps&#39;);

gulp.task(&#39;css&#39;, function () {
    var processors = [
        require(&#39;autoprefixer-core&#39;),
        require(&#39;csswring&#39;)
     ];
     return gulp.src(&#39;./src/*.css&#39;)
        .pipe(sourcemaps.init())
        .pipe(postcss(processors))
        .pipe(sourcemaps.write(&#39;.&#39;))
        .pipe(gulp.dest(&#39;./dest&#39;));
});</code></pre>
<h3>Webpack</h3>
<p>In <a href="http://webpack.github.io/">webpack</a> you can use <a href="https://github.com/postcss/postcss-loader">postcss-loader</a> to process CSS files through
an array of PostCSS processors.</p>
<pre><code class="language-js">module.exports = {
    module: {
        loaders: [
            {
                test:   /\.css$/,
                loader: &quot;style-loader!css-loader!postcss-loader&quot;
            }
        ]
    },
    postcss: [require(&#39;autoprefixer-core&#39;), require(&#39;csswring&#39;)]
}</code></pre>
<h2>Write Own Processor</h2>
<p>You can parse CSS with the <code>postcss.parse()</code> method, which returns a CSS AST:</p>
<pre><code class="language-js">var postcss = require(&#39;postcss&#39;);

var css = postcss.parse(&#39;a { color: black }&#39;);</code></pre>
<p>You can easily make changes to this AST. Use <code>css.nodes</code> to get children.
Properties <code>rule.selector</code>, <code>decl.prop</code>, <code>decl.value</code>, <code>atrule.name</code>
and <code>atrule.params</code> contain data.</p>
<pre><code class="language-js">css.nodes[0].value = &#39;white&#39;;</code></pre>
<p>After changes have been made you can get the new CSS and a source map reflecting
the modifications:</p>
<pre><code class="language-js">var result = css.toResult(options);

result.css //=&gt; &#39;a { color: white }&#39;
result.map //=&gt; &#39;{&quot;version&quot;:3, … }&#39;</code></pre>
<p>The methods <code>postcss.parse()</code> and <code>CSS#toResult()</code> are part of a low level API,
and - in most cases - it will be better to create processors with a simpler API
and chaining.</p>
<h3>Processor</h3>
<p>The function <code>postcss(fn)</code> creates a processor from your function:</p>
<pre><code class="language-js">var postcss = require(&#39;postcss&#39;);

var processor = postcss(function (css, opts) {
    // Code to modify CSS
});</code></pre>
<p>If you want to combine multiple processors (and parse the CSS only once),
you can add several functions using the <code>use(fn)</code> method:</p>
<pre><code class="language-js">var all = postcss().
          use(prefixer).
          use(minifing);</code></pre>
<p>You can also add processor objects with the <code>postcss</code> function:</p>
<pre><code class="language-js">postcss().use( autoprefixer.postcss ); // via function
postcss().use( autoprefixer );         // via object</code></pre>
<p>A processor function can change the current CSS node tree:</p>
<pre><code class="language-js">postcss(function (css) {
    css.append( /* new rule */ )
});</code></pre>
<p>or create a completely new CSS root node and return it instead:</p>
<pre><code class="language-js">postcss(function (css) {
    var newCSS = postcss.root()
    // Add rules and declarations
    return newCSS;
});</code></pre>
<p>This generated processor transforms some CSS using
the <code>process(css, opts)</code> method:</p>
<pre><code class="language-js">var doubler = postcss(function (css) {
    // Clone each declaration
    css.eachDecl(function (decl) {
        decl.parent.prepend( decl.clone() );
    });
});

var css    = &quot;a { color: black; }&quot;;
var result = doubler.process(css);

result.css //=&gt; &quot;a { color: black; color: black; }&quot;</code></pre>
<p>You can change the original CSS filename via the <code>from</code> option, which
can make syntax error more helpful:</p>
<pre><code class="language-js">var wrong = &quot;a {&quot;;
processor.process(wrong, { from: &#39;main.css&#39; });
//=&gt; Can&#39;t parse CSS: Unclosed block at line 1:1 in main.css</code></pre>
<p>Options from <code>process(css, opts)</code> will be sent to processors
as the second argument.</p>
<p>You can also use the result from a previous postprocessor, or
an already-parsed <code>Root</code>, as an argument to the next one:</p>
<pre><code class="language-js">result = processor1.process(css)
processor2.process(result)</code></pre>
<h3>Multiple Inputs</h3>
<p>The function <code>postcss()</code> generates a processor for only one input.
If you need to process several inputs (for example, when concatenating files)
you can use <code>postcss.parse()</code>.</p>
<p>Let’s join two CSS strings with full source map support in only 5 lines of code:</p>
<pre><code class="language-js">var file1 = postcss.parse(css1, { from: &#39;a.css&#39; });
var file2 = postcss.parse(css2, { from: &#39;b.css&#39; });

file1.append( file2 );

var result = file1.toResult({ to: &#39;app.css&#39;, map: true });</code></pre>
<h3>Source Map</h3>
<p>By using <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a>, a browser’s development tools can indicate the
original position of your styles before the css file was transformed.
For example, an inspector will show the position in a Sass file, even if
the file has been compiled to CSS, concatenated, and minified.</p>
<p>To ensure a correct source map is generated, every CSS processing step should
update the map generated by the previous step. For example, a Sass compiler
will generate the first map, a concatenation tool should update the Sass step’s
map, and a minifier should update the map generated by the concatenation tool.</p>
<p>There are two ways to store a source map:</p>
<ul>
<li><p>You can place it in a separate file which contains a special annotation
comments pointing to another file:</p>
<pre><code class="language-css">a { }
/*# sourceMappingURL=main.out.css.map */</code></pre>
</li>
<li><p>Or you can inline a base64-encoded source map within a CSS comment:</p>
<pre><code class="language-css">a { }
/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uY3NzIiwic291cmNlcyI6WyJtYWluLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFLIn0= */</code></pre>
</li>
</ul>
<p>PostCSS has great source map support. To ensure that you generate the correct
source map, you must indicate the input and output CSS files
paths (using the options <code>from</code> and <code>to</code> respectively).</p>
<p>To generate a new source map with the default options, provide <code>map: true</code>.
This will inline sourcemap with source content.</p>
<p>If you don&#39;t want the map inlined, you can use <code>inline: false</code>
in the options passed to <code>processor.process(css, opts)</code>.</p>
<pre><code class="language-js">var result = processor.process(css, {
    from: &#39;main.css&#39;,
    to:   &#39;main.out.css&#39;
    map: { inline: false },
});

result.map //=&gt; &#39;{&quot;version&quot;:3,&quot;file&quot;:&quot;main.out.css&quot;,&quot;sources&quot;:[&quot;main.css&quot;],&quot;names&quot;:[],&quot;mappings&quot;:&quot;AAAA,KAAI&quot;}&#39;

fs.writeFileSync(&#39;main.out.css&#39;,     result.css);
fs.writeFileSync(&#39;main.out.css.map&#39;, result.map);</code></pre>
<p>Or set <code>from</code> in <code>postcss.parse(css, opts)</code> and <code>to</code> in <code>root.toResult(opts)</code>:</p>
<pre><code class="language-js">var root = postcss.parse(css, { from: &#39;main.css&#39;, { inline: false } });
root.last.removeSelf(); // Example transformation

var result = root.toResult({ to: &#39;main.out.css&#39; });
fs.writeFileSync(&#39;main.out.css&#39;,     result.css);
fs.writeFileSync(&#39;main.out.css.map&#39;, result.map);</code></pre>
<p>If PostCSS is handling CSS and finds source maps from previous transformations,
it will automatically update the CSS with the same options.</p>
<pre><code class="language-js">// main.sass.css has an annotation comment with a link to main.sass.css.map
var result = minifier.process(css, { from: &#39;main.sass.css&#39;, to: &#39;main.min.css&#39; });
result.map //=&gt; Source map from main.sass to main.min.css</code></pre>
<p>If you want more control over source map generation, you can define the <code>map</code>
option as an object with the following parameters:</p>
<ul>
<li><p><code>inline</code> (boolean): indicates the source map should be inserted into the CSS
base64 string as a comment. By default it is <code>true</code>. But if all previous map
are in separated too, PostCSS will not inline map too.</p>
<p>If you inline a source map, <code>result.map</code> will be empty, as the source map
will be contained within the text of <code>result.css</code>.</p>
</li>
<li><p><code>prev</code> (string, object, or boolean): map content from a previous processing
step (for example, Sass compilation). PostCSS will try to read the previous
source map automatically from the comment within origin CSS, but you can also
set manually. If desired, you can omit the previous map with <code>prev: false</code>.</p>
<p>This is a source map option which can be passed to <code>postcss.parse(css, opts)</code>.
Other options can be passed to the <code>toResult(opts)</code> or <code>process(css, opts)</code>
methods.</p>
</li>
<li><p><code>sourcesContent</code> (boolean): indicates that we should set the origin content
(for example, Sass source) of the source map. By default it is <code>true</code>.
But if all previous map do not contain sources content,
PostCSS will miss it too.</p>
</li>
<li><p><code>annotation</code> (boolean or string): indicates if we should add annotation
comments to the CSS. By default, PostCSS will always add a comment with a path
to the source map. But if the previous CSS does not have an annotation
comment, PostCSS will omit it too.</p>
<p>By default, PostCSS presumes that you want to save the source map as
<code>opts.to + &#39;.map&#39;</code> and will use this path in the annotation comment.
But you can set another path by providing a string value as the <code>annotation</code>
option.</p>
<p>If you set <code>inline: true</code>, annotation cannot be disabled.</p>
</li>
</ul>
<h3>Safe Mode</h3>
<p>If you provide a <code>safe: true</code> option to the <code>process</code> or <code>parse</code> methods,
PostCSS will try to correct any syntax error that it finds in the CSS.
For example, it will parse <code>a {</code> as <code>a {}</code>.</p>
<pre><code class="language-js">postcss.parse(&#39;a {&#39;);                 // will throw &quot;Unclosed block&quot;
postcss.parse(&#39;a {&#39;, { safe: true }); // will return CSS root for a {}</code></pre>
<p>This is useful for legacy code filled with plenty of hacks. Another use case
is interactive tools with live input, for example,
the <a href="http://jsfiddle.net/simevidas/udyTs/show/light/">Autoprefixer demo</a>.</p>
<h3>Helpers</h3>
<h4>Vendor</h4>
<p>PostCSS contains height optimized code to split vendor prefix:</p>
<pre><code class="language-js">var vendor = require(&#39;postcss/lib/vendor&#39;);

vendor.prefix(&#39;-moz-tab-size&#39;)     //=&gt; &#39;-moz-&#39;
vendor.unprefixed(&#39;-moz-tab-size&#39;) //=&gt; &#39;tab-size&#39;</code></pre>
<h4>List</h4>
<p>To safely split comma- or space-separated values (such as those
in <code>background-image</code> or <code>transform</code>) with brackets and quotes support,
you can use the <code>list</code> helper:</p>
<pre><code class="language-js">var list = require(&#39;postcss/lib/list&#39;);

list.space(image.value)     //=&gt; [&#39;linear-gradient(white, black)&#39;, &#39;blue&#39;]
list.comma(transform.value) //=&gt; [&#39;color 200ms&#39;, &#39;background 200ms&#39;]</code></pre>
<h3>Nodes</h3>
<p>Processor functions receive a <code>Root</code> node which contains the CSS node tree.</p>
<pre><code class="language-js">var processor = postcss(function (cssRoot) {
});</code></pre>
<p>There are 4 types of child nodes: <code>Comment</code>, <code>AtRule</code>, <code>Rule</code> and <code>Declaration</code>.
All nodes possess <code>toString()</code> and <code>clone()</code> methods.</p>
<p>You can parse CSS and get a <code>Root</code> node by calling
the <code>postcss.parse(css, opts)</code> method:</p>
<pre><code class="language-js">var cssRoot = postcss.parse(&#39;a { }&#39;);</code></pre>
<p>Many of the methods on a node will return the current node, which enables
you to build method chains:</p>
<pre><code class="language-js">root.append( rule1 ).append( rule2 ).toString();</code></pre>
<p>If some node broke you plugin syntax you can throw CSS syntax error:</p>
<pre><code class="language-js">throw node.error(&#39;Bad variable syntax&#39;);
//=&gt; CssSyntaxError: app.css:45:5: Bad variable syntax
//   var-name: 1
//   ^</code></pre>
<h3>Node Source</h3>
<p>Every node stores its origin file (if you provide the <code>from</code> option
to the <code>process</code> or <code>parse</code> methods) and position:</p>
<pre><code class="language-js">var root = postcss.parse(css, { from: &#39;main.css&#39; });
var rule = root.nodes[0];

rule.source.input.file //=&gt; &#39;main.css&#39;
rule.source.start      //=&gt; { line: 5,  position: 1 }
rule.source.end        //=&gt; { line: 10, position: 5 }</code></pre>
<h3>Whitespace</h3>
<p>All nodes (excluding the <code>Root</code>) have a <code>before</code> property which contains
the indentation and any previous whitespace.</p>
<p>Nodes with children (<code>Root</code>, <code>AtRule</code> and <code>Rule</code>) also contain an <code>after</code>
property which indicates the spaces after the last child and before a <code>}</code>
character or the end of the file.</p>
<p>Every <code>Declaration</code> has a <code>between</code> property with colon, spaces and comments
between the property name and value. <code>Rule</code> stores the spaces and comments
between the selector and <code>{</code> in the <code>between</code> property. <code>AtRule</code> uses <code>between</code>
to indicate the spaces and comments before either a <code>{</code> or <code>;</code>, if the at-rule
is bodiless.</p>
<pre><code class="language-js">var root = postcss.parse(&quot;a {\n  color: black;\n}\n&quot;);

root.nodes[0].between          //=&gt; &quot; &quot; between selector and {
root.nodes[0].nodes[0].before  //=&gt; &quot;\n  &quot; before color: black
root.nodes[0].nodes[0].between //=&gt; &quot;: &quot; between property name and value
root.nodes[0].after            //=&gt; &quot;\n&quot; before }
root.after                     //=&gt; &quot;\n&quot; from end of file</code></pre>
<p>The simplest way to minify CSS is to set <code>before</code>, <code>between</code> and <code>after</code>
properties to an empty string:</p>
<pre><code class="language-js">var minifier = postcss(function (css) {
    css.eachDecl(function (decl) {
        decl.before  = &#39;&#39;;
        decl.between = &#39;:&#39;;
    });
    css.eachRule(function (rule) {
        rule.before  = &#39;&#39;;
        rule.between = &#39;&#39;;
        rule.after   = &#39;&#39;;
    });
    css.eachAtRule(function (atRule) {
        atRule.before  = &#39;&#39;;
        atRule.between = &#39;&#39;;
        atRule.after   = &#39;&#39;;
    });
    css.eachComment(function (comment) {
        comment.removeSelf();
    });
});

var css = &quot;a {\n  color:black\n}\n&quot;;
minifier.process(css).css //=&gt; &quot;a{color:black}&quot;</code></pre>
<p>Note that nodes may have not <code>before</code> or <code>between</code> properties:</p>
<ul>
<li>If node was created by hand via <code>postcss.rule()</code>.</li>
<li><code>node.clone()</code> will clean all style properties to use the style
for a new CSS root.</li>
</ul>
<h3>Raw Properties</h3>
<p>Some CSS values (selectors, comment text, at-rule params and declaration values)
can contain comments. PostCSS will clean them to remove trailing spaces:</p>
<pre><code class="language-js">var root = postcss.parse(&quot;a /**/ b {}&quot;);
var rule = root.first;

rule.selector      //=&gt; &#39;a  b&#39; trimmed and cleaned from comments
rule._selector.raw //=&gt; &#39;a /**/ b&#39; original raw value</code></pre>
<p>But PostCSS preservers the raw content in order to stringify it back to CSS,
in case you don’t change the original value. In general, PostCSS tries
to preserve the original CSS byte-to-byte whenever possible:</p>
<pre><code class="language-js">rule.toString() //=&gt; &#39;a /**/ b {}&#39; with comment

rule.selector = &#39;.link b&#39;;
rule.toString() //=&gt; &#39;.link b {}&#39; you change value and origin comment was gone</code></pre>
<h3>Containers</h3>
<p><code>Root</code>, <code>AtRule</code> and <code>Rule</code> nodes can contain children in <code>nodes</code> property.</p>
<p>There are some common methods to perform work on children:</p>
<ul>
<li><code>append(newChild)</code> adds a child at the end of the children list.</li>
<li><code>prepend(newChild)</code> adds a child at the beginning of the children list.</li>
<li><code>insertBefore(existsChild, newChild)</code> inserts a new child before a
 pre-existing child.</li>
<li><code>insertAfter(existsChild, newChild)</code> inserts a new child after some
 pre-existing child.</li>
<li><code>remove(existsChild)</code> removes a child.</li>
<li><code>removeAll()</code> to remove all children.</li>
<li><code>index(existsChild)</code> returns a child’s index.</li>
<li><code>some(fn)</code> returns true if <code>fn</code> returns true for any child.</li>
<li><code>every(fn)</code> returns true if <code>fn</code> returns true for all children.</li>
</ul>
<p>Methods <code>append</code>, <code>prepend</code>, <code>insertBefore</code> and <code>insertAfter</code> will also accept
arrays and <code>Root</code> nodes as an argument.</p>
<p>Methods <code>insertBefore</code>, <code>insertAfter</code> and <code>remove</code> will accept child nodes
or indexes as the <code>existsChild</code> argument. Note that providing a child index will
result in the method completing much faster.</p>
<p>You can combine <code>node.clone()</code> and <code>node.parent.insertBefore()</code>
by <code>node.cloneBefore()</code> and <code>node.cloneAfter()</code> methods.</p>
<p>There are two shortcuts to provide the first and last child of a node:</p>
<pre><code class="language-js">rule.first //=&gt; First declaration in rule
rule.last  //=&gt; Last declaration in rule</code></pre>
<h3>Children</h3>
<p><code>Comment</code>, <code>AtRule</code>, <code>Rule</code> and <code>Declaration</code> nodes should be wrapped
in other nodes.</p>
<p>All children contain a <code>parent</code> property which indicates the parent node:</p>
<pre><code class="language-js">rule.nodes[0].parent == rule;</code></pre>
<p>All children have a <code>removeSelf()</code> method:</p>
<pre><code class="language-js">rule.nodes[0].removeSelf();</code></pre>
<p>But invoking the <code>remove(index)</code> method on the parent is much faster:</p>
<pre><code class="language-js">rule.each(function (decl, i) {
    rule.remove(i);
});</code></pre>
<p>You can move nodes between parents by <code>moveTo()</code>, <code>moveBefore()</code>
and <code>moveAfter()</code> methods.</p>
<p>To replace node by other one use <code>node.replaceWith(other)</code> method.</p>
<p>Methods <code>prev()</code> and <code>next()</code> returns previous and next child in node parent.</p>
<h3>Iterators</h3>
<p>All parent nodes have an <code>each</code> method which allows you to iterate over
its child nodes:</p>
<pre><code class="language-js">root = postcss.parse(&#39;a { color: black; display: none }&#39;);

root.each(function (rule, i) {
    if ( rule.type == &#39;rule&#39; ) {
        console.log(rule.selector, i); // Will log &quot;a 0&quot;
    }
});

root.first.each(function (decl, i) {
    if ( rule.type != &#39;comment&#39; ) {
        console.log(decl.prop, i); // Will log &quot;color 0&quot; and &quot;display 1&quot;
    }
});</code></pre>
<p>Unlike <code>for {}</code>-cycle construct or <code>Array#forEach()</code> this iterator is safe.
So you can mutate the children during iteration and PostCSS will fix
the current index:</p>
<pre><code class="language-js">rule.nodes.forEach(function (decl, i) {
    rule.prepend( decl.clone() );
    // Will infinitely cycle as prepending the current declaration will
    // cause the second and successive indexes to interact with the
    // current declaration endlessly
});

rule.each(function (decl, i) {
    rule.prepend( decl.clone() );
    // Will work correctly (each declaration will be cloned only once),
    // because the iterator index will be recalculated only after the prepend
});</code></pre>
<p>Because CSS has a nested structure, PostCSS also features a recursive iterator
<code>eachInside</code>:</p>
<pre><code class="language-js">root.eachInside(function (node, i) {
    console.log(node.type + &#39; inside &#39; + node.parent.type);
});</code></pre>
<p>There are also shortcuts so that you can recursively iterate over nodes
of a specific type:</p>
<pre><code class="language-js">root.eachDecl(function (decl, i) {
    // Each declaration inside root
});

root.eachRule(function (rule, i) {
    // Each rule inside root and any nested at-rules
});

root.eachAtRule(function (atRule, i) {
    // Each at-rule inside root and any nested at-rules
});

root.eachComment(function (comment, i) {
    // Each comment inside root
})</code></pre>
<p>Methods <code>eachDecl()</code> and <code>eachAtRule()</code> also accept a string or regexp
filter to only iterate over declarations with some property name
or for at-rules with some name.</p>
<pre><code class="language-js">root.eachDecl(/^background/, function (decl) {
    inlineImages(decl);
});</code></pre>
<p>You can break out from the iteration by returning <code>false</code>.</p>
<p>If you want to change values in all children, you can use very <code>replaceValues</code>
method:</p>
<pre><code class="language-js">root.replaceValues(/\d+(\.\d+)?rem/,
    { props: [&#39;width&#39;, &#39;height&#39;], fast: &#39;rem&#39; }, function (str) {
        var rem = parseFloat(str);
        return 16 * rem;
    })</code></pre>
<p>Option <code>fast</code> will be used for fast precheck by <code>indexOf()</code>.</p>
<h3>Root Node</h3>
<p><code>Root</code> node contains the entire CSS tree. Its children can only be <code>Comment</code>,
<code>AtRule</code>, or <code>Rule</code> nodes in the <code>nodes</code> property.</p>
<p>You can create a new root using the shortcut:</p>
<pre><code class="language-js">var root = postcss.root();</code></pre>
<p>Method <code>toString()</code> stringifies the entire node tree and returns a CSS string:</p>
<pre><code class="language-js">root = postcss.parse(css);
root.toString() == css;</code></pre>
<p>If PostCSS found previous source map, it will save all the relevant information
within <code>Root#prevMap</code>:</p>
<pre><code>root = postcss.parse(css);
if (root.prevMap &amp;&amp; root.prevMap.inline) {
    console.log(&#39;Inlined map: &#39; + root.prevMap.annotation)
}</code></pre>
<h3>Comment Node</h3>
<pre><code class="language-css">/* Block comment */</code></pre>
<p>PostCSS creates <code>Comment</code> nodes only for comments found between rules
or declarations. Comments found within selectors, at-rules params,
or declaration values will be stored in the Raw property.</p>
<p><code>Comment</code> has only one property: <code>text</code> which contains the trimmed text inside
the comment.</p>
<pre><code class="language-js">comment.text //=&gt; &quot;Block comment&quot;</code></pre>
<p>You can create a new comment using a shortcut:</p>
<pre><code class="language-js">var comment = postcss.comment({ text: &#39;New comment&#39; });</code></pre>
<h3>AtRule Node</h3>
<pre><code class="language-css">@charset &#39;utf-8&#39;;

@font-face {
    font-family: &#39;Cool&#39;
}

@media print {
    img { display: none }
}</code></pre>
<p><code>AtRule</code> has two own properties: <code>name</code> and <code>params</code>.</p>
<p>As illustrated above, some at-rules do not contain any children
(for example, <code>@charset</code> or <code>@import</code>), some at-rules can only contain
declarations (for example, <code>@font-face</code> or <code>@page</code>), but most of them
can contain rules and nested at-rules (for example, <code>@media</code>, <code>@keyframes</code>
and others).</p>
<p>You can create a new at-rule using a shortcut:</p>
<pre><code class="language-js">var atRule = postcss.atRule({ name: &#39;charset&#39;, params: &#39;utf-8&#39; });</code></pre>
<h3>Rule Node</h3>
<pre><code class="language-css">a {
    color: black;
}</code></pre>
<p><code>Rule</code> nodes have a <code>selector</code> property and contain their <code>Declaration</code>
and <code>Comment</code> children within the <code>nodes</code> property.</p>
<p>They also possess a <code>selectors</code> shortcut, which returns an array:</p>
<pre><code class="language-js">rule.selector  //=&gt; &quot;a, b&quot;
rule.selectors //=&gt; [&#39;a&#39;, &#39;b&#39;]</code></pre>
<p>You can avoid using the <code>Declaration</code> constructor for <code>append</code>
and other insert methods, by:</p>
<pre><code class="language-js">rule.append({ prop: &#39;color&#39;, value: &#39;black&#39; });</code></pre>
<p>The property <code>semicolon</code> indicates if the last declaration within the rule has
a semicolon or not:</p>
<pre><code class="language-js">var root = postcss.parse(&#39;a { color: black }&#39;);
root.first.semicolon //=&gt; false

var root = postcss.parse(&#39;a { color: black; }&#39;);
root.first.semicolon //=&gt; true</code></pre>
<p>You can create a new rule using a shortcut:</p>
<pre><code class="language-js">var rule = postcss.rule({ selector: &#39;a&#39; });</code></pre>
<h3>Declaration Node</h3>
<pre><code class="language-css">color: black</code></pre>
<p><code>Declaration</code> nodes have <code>prop</code>, <code>value</code> and <code>important</code> properties.</p>
<p>You can create a new declaration using a shortcut:</p>
<pre><code class="language-js">var decl = postcss.decl({ prop: &#39;color&#39;, value: &#39;black&#39; });</code></pre>
<p>Or you can use the short form available via a rule’s <code>append()</code> and other
add methods:</p>
<pre><code class="language-js">rule.append({ prop: &#39;color&#39;, value: &#39;black&#39; });</code></pre>
<footer g="md-margin-t"><ul g="md-container lg-padding-tb centered"><li><a href="https://twitter.com/BNOTIONS" class="twitter-follow-button" data-show-count="false">Follow @BNOTIONS</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li></ul></footer></body></html>